xp-vpn-stack/0000_Erklärung.txt
================================================================================
TITLE: Erklärung / Wie dieses Repo gelesen wird
VERSION: v2.5
DATUM: 2026-01-15
STATUS: ACCEPTED
OWNER-INTENT: Orientierung: erklärt Master/Blocks/Decisions/Changelog und wie Inhalte kanonisch referenziert werden.
OWNER: Marco (Owner) + ChatGPT (Co-Architect)
================================================================================
0000_Erklärung.txt (v2.4)

00_MASTER_v2.4.txt (Inhalt/Format)

Ziel: Das ist die Datei, die du immer “komplett” rausgeben kannst, wenn du sagst „gib mir das ganze Konzept“.
Sie enthält keine Details doppelt, sondern verweist auf Blocks.

Aufbau:

Header (Version, Datum, Status)

“Regeln” (keine Neuinterpretation, alles detailiert, keine Kürzung)

Kurzübersicht Architektur (1 Seite)

Blockliste (IDs + Titel)

Abhängigkeiten (Graph in Textform)

“Aktive Entscheidungen” (z.B. OpenResty fix, SQL-first fix, Restricted Hard-Cut (conntrack+PPP-kill Fail-Safe), Hybrid Retention+Ring-Buffer (Drop Oldest), Stale-Session Janitor VALID-Mapping+Permissions+On-Demand Cache/Fallback)

Tasks-Hybrid:
- 0_MASTERKONZEPT_ANALYSE.md ist die Abarbeitungs-/Abarbeitungs-Datei (Hybrid).
- tasks/ enthält optionale Workspace-Dateien/Prüfkonzepte, die in der Analyse referenziert werden können.

Verweis auf Changelog + Glossar

Block-Index (04_BLOCK_INDEX.txt)

Format je Block:

[BLOCK-ID] [Titel]
- Datei: blocks/Bxxx_*.txt
- Status: ACTIVE | DRAFT | DEPRECATED
- Pflichtgrad: MUST | SHOULD | OPTIONAL
- Abhängigkeiten: Bxxx, Byyy, ...
- Liefert: (Outputs)
- Nutzt: (Inputs)
- Letzte Änderung: v2.0.1 / YYYY-MM-DD


Block-Datei Standard (templates/BLOCK_TEMPLATE.txt)

HINWEIS (Template-Platzhalter):
- Der folgende Ausschnitt ist ein reines Template-Beispiel aus templates/ und darf Platzhalter wie "<...>" sowie "..." enthalten.
- In kanonischen Dateien (Root/blocks/decisions) sind solche Platzhalter nicht erlaubt; dort müssen alle Felder final befüllt sein.

Das ist die “zeilenfeste” Struktur, die jede Blockdatei exakt nutzt:

================================================================================
BLOCK-ID: B000
TITLE: <Kurz & eindeutig>
VERSION: v1.0 (Block-Version, unabhängig vom Master)
STATUS: ACTIVE | DRAFT | DEPRECATED
PRIORITY: MUST | SHOULD | OPTIONAL
OWNER-INTENT: (Warum existiert der Block?)
================================================================================

1) ZWECK (WAS wird gelöst?)
- …

2) GRENZEN (WAS wird explizit NICHT gelöst?)
- …

3) ABHÄNGIGKEITEN
- Requires: Bxxx, Byyy
- Influences: Bzzz

4) INPUTS
- Interfaces: …
- IP-Ranges: …
- Credentials/DB: …
- Services: …

5) OUTPUTS
- Verhalten/Guarantees: …
- Ports exposed (internal): …
- Ports exposed (WAN): …

6) HARTE REGELN (MUST)
- …

7) OPTIONEN (SHOULD/OPTIONAL)
- …

8) FEHLERBILDER & DIAGNOSE
- Symptom → Ursache → Fix

9) TESTS / ACCEPTANCE CRITERIA
- …

10) CHANGELOG (Block-intern)
- v1.0: …
- v1.1: …
================================================================================


Decision Records (optional, aber extrem hilfreich)

Wenn du später sagst “warum OpenResty?” oder “warum SQL first?” → du brauchst ein Decision-Log.

Ordner:

decisions/
├─ D001_OPENRESTY_OVER_APACHE.txt
├─ D002_SQL_FIRST_NO_MIGRATION.txt
├─ D003_TWO_NETS_USER_ADMIN.txt
├─ D004_MITM_BLOCKPAGE_APPROACH.txt
├─ D005_OFFLOAD_DEFAULT_VM.txt
├─ D006_NTP_MANDATORY_XP.txt
├─ D007_SUBACCOUNTS_PER_DEVICE.txt
├─ D008_VERIFY_WALL_CUSTOMER_SCOPE.txt
├─ D010_RADIUS_EMISSION_TMPSTRINGS.txt
├─ D011_REASON_CODE_FAMILIES_AND_SOT.txt
└─ D012_SESSION_CONTROL_A_B.txt


Template:

DECISION-ID: D000
TITLE: …
DATE: …
STATUS: ACCEPTED | SUPERSEDED | REJECTED

CONTEXT:
- …

DECISION:
- …

ALTERNATIVES:
- …

CONSEQUENCES:
- Positive:
- Negative:
- Mitigations:

LINKED BLOCKS:
- Bxxx, Byyy


Abhängigkeits-Graph (Textform)

Damit du sofort siehst, was wovon abhängt:

B020 Goals → steuert alle

B040 Stack → bedingt B070, B080, B090, B100…

B050 SQL/RADIUS → bedingt B150 (Restricted/Quota), B155 (State Machine), B160 (QoS aus DB),
B165 (Accounting Collector / Session Mapping), B166 (Policy Apply/Reconcile), B167 (Hooks/systemd),
B168/B169 (Stale/On-demand Login Flow), B280 (Panel), B270 (Diag)
B171 (Session-Control Anchor; Decision D012) als kanonischer Knotenpunkt für Guard/Repair/Override


B150 Walled Garden → bedingt B166 (restricted set rebuild), B210 (DNS im Restricted Mode erlaubt),
B220/B280 (Portal/Panel erreichbar)

B220 Webstack → bedingt B230 MITM, B280 Panel, B270 /diag

B200 DNS → bedingt B210 DNS-Zwang (DNAT53), B230 Blockpage Routing

B260 NTP → bedingt B230/Panel/Setup-Tool (TLS-Zertifikate nutzbar)


Kurze “Masterdatei Regeln” (03_ASSUMPTIONS_AND_RULES.txt)

Hier stehen dauerhaft die Meta-Regeln rein:

keine Neuinterpretation

keine Kürzung

jede Änderung = neue Masterversion

jede Änderung muss in Changelog + betroffene Blockdatei eingetragen werden

Versionierung:

Master: v2.x

Blocks: v1.x pro Block (Block-Version unabhängig vom Master)

Namensregeln: Interface ens13 als Default, aber dokumentierbar austauschbar.

Wichtig (v2.0-Update, explizit):

DNS-ZWANG ist IMMER aktiv (MUST): DNAT TCP+UDP 53 von iif ppp* -> 10.77.0.1:53.

Onboarding ist App-Layer:
- Verify-Wall: Panelzugriff ist bis zur Email-Code-Bestätigung auf die Verify-Seite begrenzt.
- Claim läuft per Claim-Token im Panel (Claim-only; nicht VPN-Login) (Verify-Wall + Claim-Token + Grace/Overdue).

Restricted Mode (Kernel / nftables) ist davon getrennt und wird nur aktiv durch:
- Quota / Expiry / Manual
- UNCLAIMED_OVERDUE (z.B. nach 30 Tagen Grace-Zeitraum)

Policy-Enforcement ist deterministisch (B166/B167): Drift wird über Reconcile (<=5min) verhindert.

Stale-Session/SimUse Lockout wird aktiv gelöst (B168/B169) statt “weicher SimUse” oder “parallel sessions”.


Wichtig (v2.3-Update, explizit):

Restricted Mode Enforcement ist HARD CUT (MUST):
- Bei State-Change FULL -> RESTRICTED MUSS Enforcement „sofort“ auch für established flows wirken.
- Mechanismus: Policy/Kernel-Enforcement aktivieren -> conntrack flush (bidirektional: Source+Destination) -> danach greifen Regeln auch für ehemals established Flows.
- Fail-Safe (MUST): Wenn conntrack-flush scheitert -> PPP-Session kill (fail-closed, deterministisch).
- Doppel-Fehlschlag (flush fail + kill fail) ist FATAL (Alert/Monitoring Pflicht).

Logging/Retention/Spool Safety ist Hybrid (MUST):
- SQL-first Settings sind Policy-Quelle; lokale Safety Ceilings sind Physik-Grenze (effective = min(SQL, local ceiling)).
- Bei Ceiling-Hit (Spool/Logs) gilt Drop/Ring-Buffer (Drop Oldest) MUST + zwingender Alert.

Stale-Session Management ist „Kernel-Truth“ (MUST):
- Mapping-Dateien sind nur gültig, wenn VALID (Interface-Existenz + PID + START_TS / PID-Reuse Schutz).
- /run/vpn-sessions/ Integritätsschutz (MUST): root-only write (chmod/chown normativ), keine Manipulation durch Web-User.
- On-Demand Janitor (Login-getriggert) soll Cache/Fallback nutzen, um SQL-DoS im Login-Pfad zu vermeiden (SHOULD).

================================================================================
CHANGELOG
================================================================================

================================================================================