xp-vpn-stack/blocks/B055_DB_SCHEMA_CORE.txt
================================================================================
BLOCK-ID: B055
TITLE: DB Schema Core (customers, vpn_connections, active_session_locks)
VERSION: v1.10
DATUM: 2026-01-14
STATUS: ACTIVE
PRIORITY: MUST
REQUIRES: B050
INFLUENCES: alle
OWNER-INTENT: Verbindliches SQL-first Schema als Single Source of Truth (Stabilität + deterministische Regeln): Claim/Restricted als deterministische State-Machine; SimUse ist bewusst Modell A+B (radacct=Truth + active_session_locks=Guard/Mutex, kein Lifecycle).
OWNER: Marco (Owner) + ChatGPT (Co-Architect)

NOTES:
- Core-Schema bleibt bewusst klein und stabil; neue Features sollen neue Tabellen bekommen, nicht „Core aufblasen“.
- Keine History/Forensics in Core-Tabellen: Verlaufsdaten gehen in Logs/Accounting/Separate Historientabellen.
- active_session_locks ist ein Atomar-Lock: muss crash-sicher auflösbar sein (Janitor) und gegen Parallel-Connects schützen.
================================================================================

================================================================================
1) INHALT
================================================================================

## 1) Purpose
Define core DB schema for:
- customers (panel account)
- vpn_connections (device/subaccount)
- active_session_locks (atomic SimUse guard)
- plus minimal indices required for high-performance reconcile

## 2) Core Tables

### 2.1 customers
- id (PK)
- email (UNIQUE)
- password_hash (Argon2id)
- display_name (VARCHAR(40), NULL allowed; UI-only; Panel greeting; Fallback=email; output must be escaped)
- created_at
- email_verified_at (TIMESTAMP, NULL bis Verify erfolgreich; Customer ist erst danach ACTIVE)
- status (ENUM: PENDING | ACTIVE | SUSPENDED | DELETED)
- (panel-only meta)

Indexes:
- UNIQUE(email)

### 2.2 vpn_connections (pro Gerät / VPN-Client / Subaccount)
- id (PK)
- customer_id (FK, NULL bis Claim)
- subaccount_login (PPP/RADIUS Username; pro Gerät; UNIQUE; serverseitig generiert; niemals user-supplied; nicht-enumerierbar)
  - Format (kanonisch): "vpn_" + 16 Zeichen Base32 (Alphabet: a-z2-7)
  - Ziel: keine ableitbaren/fortlaufenden IDs (Enumeration verhindern)
- subaccount_nt_hash (MSCHAPv2 Secret als NT-Hash; SoT; kein Klartext-SoT)
- fixed_ip (IPv4; PPP-IP; RADIUS Framed-IP-Address; fix pro Connection)
- status (ENUM: PREPROVISIONED | CLAIMED | DISABLED)
- claim_token_hash (UNIQUE) <-- Hash des Claim-Tokens (claim_token Klartext existiert nur auf Gerät/Sticker/Label; NIE für VPN-Login)
- claimed_at (timestamp, NULL bis Claim)
- unclaimed_grace_until (timestamp) <-- bis dahin FULL, danach UNCLAIMED_OVERDUE -> restricted
- claim_deadline (timestamp) <-- Hard-Stop: Default created_at + 180d (Claim möglich bis dahin, danach DISABLED)
- restricted_reason (ENUM: QUOTA | EXPIRY | MANUAL | UNCLAIMED_OVERDUE, NULL wenn unrestricted)
  <-- Kernel/nftables Effective Reason (Performance/Debug). Wird deterministisch durch Apply/Reconcile gesetzt (B166), niemals user-supplied.
- restricted_effective (BOOL/TINYINT; 1 wenn restricted_reason != NULL, sonst 0)
  <-- Performance-Flag: Fast Path ohne Join-heavy Evaluate. Wird nur vom Server gepflegt (B166), keine UI-Quelle.
- created_at
- updated_at

Indices:
- UNIQUE(subaccount_login)
- UNIQUE(claim_token_hash)
- INDEX status
- INDEX customer_id
- INDEX fixed_ip
- INDEX unclaimed_grace_until
- INDEX claim_deadline
- INDEX restricted_effective
- INDEX restricted_reason

### 2.3 active_session_locks
Atomic guard (Mutex) against SimUse race (radacct is Truth for “session active”, this table is NOT a session-state)
- id (PK)
- vpn_connection_id (FK vpn_connections.id)
- session_key (VARCHAR)  <-- rein diagnostisch (z.B. derived from NAS-IP-Address + Calling-Station-Id + username)
- acquired_at (DATETIME)
- expires_at (DATETIME)  <-- MUST: NOW()+20s (Guard TTL; D012/B056)
- state (enum: held, released)  <-- OPTIONAL, DIAGNOSTIC ONLY (kein Lifecycle / keine Logikquelle)
- release_reason (nullable)     <-- OPTIONAL, DIAGNOSTIC ONLY

Constraints:
- UNIQUE(vpn_connection_id)  <-- SimUse=1 guard
- INDEX(expires_at)          <-- janitor scans

Kanonisches Verhalten (A+B):
- Acquire: authorize end (kurz vor OK/ACCEPT) -> INSERT lock (expires_at=NOW()+20s)
- Release: accounting Acct-Start -> DELETE lock (Guard muss weg, sobald radacct Truth ist)
- Expired locks dürfen im Auth-Pfad ignoriert/gelöscht werden (idempotent); verhindern keinen dauerhaften Lockout.

## 3) Notes / Constraints
- vpn_connections.restricted_effective is the performance field (avoid join-heavy evaluate path).
- active_session_locks must be used by B056 (RADIUS schema mapping) + B310 (acceptance tests / SimUse atomic guard).
- Verify-Code (email_verify_code) ist NON-CORE transient Security State: Hash/TTL/RateLimit/Lockout in customer_email_verify (SQL-first), Schalter email_verified_at liegt in customers.


================================================================================
4) NON-CORE EXTENSIONS (SQL-FIRST SETTINGS REGISTRY, MUST)
================================================================================
Ziel: SQL-first Policy/Parameter sind referenzierbar und auditierbar (kein Drift von “losen Zahlen” in Text/Configs).
Diese Tabellen gehören NICHT in die Core-Tabellen customers/vpn_connections/active_session_locks, sondern sind bewusst separate Extensions.

A) settings_global (MUST)
- setting_key (PK, VARCHAR)  -- z.B. "log_detailed_retention_days"
- value (VARCHAR)            -- typed via value_type
- value_type (ENUM: int,bool,string,seconds,ms,bytes)
- updated_at (TIMESTAMP)
- updated_by (VARCHAR)       -- admin identifier (UI/audit)
- comment (TEXT, optional)
- Optional: min_value/max_value (für UI-Guard; Hard Caps bleiben trotzdem lokal im Code)

B) settings_customer (OPTIONAL, wenn per Kunde/Plan variieren soll)
- customer_id (FK -> customers.id)
- setting_key, value, value_type, updated_at, updated_by, comment, min_value, max_value
- PK: (customer_id, setting_key)

C) settings_connection (OPTIONAL, wenn per vpn_connection_id variieren soll)
- vpn_connection_id (FK -> vpn_connections.id)
- setting_key, value, value_type, updated_at, updated_by, comment, min_value, max_value
- PK: (vpn_connection_id, setting_key)

D) customer_email_verify (MUST)
Ziel: Verify-Code (email_verify_code) ist kurzlebig + single-use + nicht im Klartext persistiert.
Diese Tabelle ist bewusst NON-CORE (transient Security Artefakte), aber SQL-first SoT für Verify/RateLimit/Lockout-Status.

- customer_id (PK, FK -> customers.id)
- verify_code_hash (VARBINARY/CHAR; Hash des Codes; Klartext wird nie gespeichert)
- verify_code_expires_at (TIMESTAMP)   -- TTL, nach Ablauf ungültig
- verify_code_sent_at (TIMESTAMP)      -- Diagnose/Audit: wann zuletzt gesendet
- resend_count (INT)                   -- Zähler im aktuellen Window (SQL-first RateLimit)
- resend_window_started_at (TIMESTAMP) -- Beginn des aktuellen Resend-Windows
- attempt_count (INT)                  -- Zähler falscher Eingaben im aktuellen Window
- attempt_window_started_at (TIMESTAMP)-- Beginn des aktuellen Attempt-Windows
- locked_until (TIMESTAMP, NULL)       -- Lockout bis Zeit X (SQL-first Policy)
- updated_at (TIMESTAMP)

Indexes:
- (optional) INDEX(verify_code_expires_at) -- falls Janitor/cleanup per DB-Scan vorgesehen

Regeln (KANONISCH):
- SQL liefert “Target Values” (Policy); lokale Hard Caps/Safety Ceilings werden IMMER im Code erzwungen (Physik > Policy).
- Wenn SQL down/timeout: Notfall-Fallbacks greifen (in den jeweiligen Blocks definiert), System bleibt deterministisch.

================================================================================
CHANGELOG
================================================================================
- v1.10 (2026-01-14): Schema-Konsistenz: vpn_connections um restricted_reason (QUOTA/EXPIRY/MANUAL/UNCLAIMED_OVERDUE) + restricted_effective ergänzt inkl. Indizes; Align zu B050/B166 (Restricted ist Kernel/nftables-Effective, server-managed).
- v1.9 (2026-01-14): customers erweitert für Onboarding: email_verified_at + Status ENUM PENDING/ACTIVE/SUSPENDED/DELETED; NON-CORE Extension customer_email_verify ergänzt (verify_code_hash + TTL + RateLimit/Lockout State für Verify-Code/email_verify_code).
- v1.8 (2026-01-14): 3.2 SQL-first SoT: Settings Registry als NON-CORE Extension ergänzt (settings_global + optional customer/connection Scopes). Hard Caps bleiben lokal (Physik > Policy). Keine Änderung an Core-Tabellen beschrieben.
- v1.7 (2026-01-14): subaccount_login Constraints kanonisiert (server-generated, Format vpn_+16 Base32 a-z2-7, non-enumerable) und claim_token_hash Kommentar redaktionell bereinigt.
- v1.6 (2026-01-14): Redaktion: OWNER-INTENT präzisiert – SimUse ist kein State-Machine-Thema, sondern Modell A+B (radacct Truth + Guard/Mutex). Inhalt/Schema unverändert.
- v1.5 (2026-01-14): active_session_locks kanonisiert als Guard/Mutex (kein Lifecycle/kein Truth): TTL=20s, Release auf Acct-Start (DELETE), state/release_reason nur diagnostisch.
- v1.4 (2026-01-14): customers.display_name (UI-only, VARCHAR(40)) als kanonisches Schema-Feld ergänzt (Panel-Greeting; Fallback=email; escaped output).
- v1.3 (2026-01-12): Task-Referenzen entfernt (T02/T09) und auf kanonische Blocks umgestellt (B056/B310).
- v1.2 (2026-01-09): vpn_connections Feldnamen/SoT vereinheitlicht: token -> claim_token_hash; subaccount_secret -> subaccount_nt_hash; Pflichtfelder (subaccount_login, fixed_ip, claim_deadline) im Schema-Block ergänzt; Indizes angepasst.
- v1.1 (2026-01-08): vpn_connections Schema an v2.1.1 State-Machine angepasst (status PREPROVISIONED/CLAIMED/DISABLED, claim_deadline MUST 180d, Grace/Deadline timestamps, restricted_reason ENUM). Terminologie bereinigt (keine Gates).
- v1.0 (2026-01-07): Neu angelegt. Inhalt aus T01_DB_SCHEMA_CORE (v0.7) in Block-Form übernommen (ohne inhaltliche Änderung).
================================================================================
END BLOCK B055
================================================================================