xp-vpn-stack/blocks/B167_WIRING_HOOKS_SYSTEMD.txt
================================================================================
BLOCK-ID: B167
TITLE: Wiring: Hooks + systemd (Apply/Collector/Timer)
VERSION: v1.15
DATUM: 2026-01-14
STATUS: ACTIVE
PRIORITY: MUST
REQUIRES: B165, B166
INFLUENCES: B310
OWNER-INTENT: Legt verbindlich fest, wo welche Logik läuft (Hooks/Services/Timer), damit Betrieb reproduzierbar und supportbar ist.
OWNER: Marco (Owner) + ChatGPT (Co-Architect)

NOTES:
- Kanonische Integrationspunkte sind systemd Units/Timer und pppd ip-up/ip-down Hooks – keine „Cron-Flicks“.
- Start-Reihenfolge/Dependencies müssen deterministisch sein (network-online, strongSwan, xl2tpd, danach Hooks).
- Hook-Skripte müssen fehlerfest sein (set -e, Logging, Timeouts), sonst reißen sie Connect/Disconnect auf.
================================================================================

================================================================================
1) ZWECK
================================================================================
- Verbindliche Verdrahtung (Wiring), wo welche Logik aufgerufen wird.
- Definiert Hook-Punkte + systemd Services/Timer für:
  - Policy Apply/Reconcile (B166)
  - Accounting Collector (B165)

================================================================================
2) NAMEN UND PFADE (KANONISCH)
================================================================================
- Zentrales Policy-Tool:
  - /usr/local/bin/vpn-policy-apply
- (Optional) Zentrales Accounting-Tool:
  - /usr/local/bin/vpn-accounting-collector
- /usr/local/bin/vpn-session-kill

- PPP Hooks:
  - /etc/ppp/ip-up.d/99-vpn-hooks
  - /etc/ppp/ip-down.d/99-vpn-hooks

- Runtime Mapping (volatile):
  - /run/vpn-sessions/<ppp_if>.env   (B165)
- Runtime-Aktivität (KANONISCH):
  - "vpn_connection_id aktiv?" => true genau dann, wenn mindestens ein VALID Runtime-Mapping in /run/vpn-sessions/*.env existiert,
    dessen CONNECTION_ID=<id> ist (Definition VALID siehe B168; B165 ist darauf abgestimmt).
  - Konsequenz: Bloße Dateiexistenz ist NICHT ausreichend (Ghost-File Problem).
  - Diese Runtime-Quelle (VALID Mapping) ist führend für Janitor/Safety Checks (B168/B169) und Reconcile.
- Durable Accounting State + Spool:
  - /var/lib/vpn-accounting/         (B165)

================================================================================
3) CONNECT TRIGGER (ip-up)
================================================================================
- Event: PPP-Session kommt hoch (pppX ist da, CLIENT_IP vergeben)
- Verantwortlich: /etc/ppp/ip-up.d/99-vpn-hooks

0) D1a CONNECT-GATE (NO-UNPOLICED-WINDOW, KEIN DEFAULT-RESTRICTED):
   - Sofort (VOR jedem SQL Zugriff) CLIENT_IP in nftables set connect_pending_v4 eintragen.
   - Semantik: connect_pending_v4 => DROP ALL im forward path (siehe B120/B150, Decision D009).
   - Erst nach erfolgreichem vpn-policy-apply (Exit 0) darf ip-up CLIENT_IP aus connect_pending_v4 entfernen.
   - Bei TEMPFAIL_SQL/ERROR/TIMEOUT: FAIL-CLOSED => PPP Kill; Gate bleibt bis Cleanup bestehen.

MUSS ausführen (Reihenfolge):
1) Session-Mapping erzeugen/aktualisieren (B165):
   - /run/vpn-sessions/<ppp_if>.env
   - Muss enthalten (MINIMUM, MUST):
     - CONNECTION_ID (wird vorher per SQL Lookup gemäß Regel unten ermittelt)
     - PPP_IF
     - CLIENT_IP
     - START_TS
     - PPPD_PID
   - Optional (nur Diagnose, kein Kill-Handle):
     - SESSION_ID

2) Policy sofort anwenden (B166, STRICT):
   - vpn-policy-apply --connection-id=<CONNECTION_ID>   (CONNECTION_ID = vpn_connection_id; siehe B166)

Regel:
- PPP Username Quelle für ip-up ist primär: PEERNAME (pppd env).
- Fallbacks (nur wenn PEERNAME leer):
  - USER
  - PPPLOGNAME
- Wenn PPP Username nicht ermittelbar ist => Mapping wird NICHT geschrieben und vpn-policy-apply wird NICHT ausgeführt.
  FAIL-CLOSED (MUST): ip-up MUSS die PPP-Session sofort beenden (PPP-kill), damit kein unpoliced window entsteht (Fehler -> Diagnose + Alert gemäß B330).
  PPP-kill erfolgt deterministisch über PPPD_PID aus dem pppd/ip-up Environment (FORBIDDEN: pgrep/ps).
- ip-up ermittelt CONNECTION_ID deterministisch per SQL Lookup über den authentifizierten PPP Username.
- Der PPP Username MUSS identisch sein mit vpn_connections.subaccount_login (eindeutig/UNIQUE).
- Lookup (konzeptionell):
  - - SELECT id FROM vpn_connections WHERE subaccount_login=<PPP_USERNAME> AND status IN ('PREPROVISIONED','CLAIMED');
- Wenn Lookup fehlschlägt (kein Treffer / mehrere Treffer / SQL nicht erreichbar) => Mapping wird NICHT geschrieben und vpn-policy-apply wird NICHT ausgeführt.
  FAIL-CLOSED (MUST): ip-up MUSS die PPP-Session sofort beenden (PPP-kill), damit kein unpoliced window entsteht (Fehler -> Diagnose + Alert gemäß B330).
   - PPP-kill erfolgt deterministisch über PPPD_PID aus dem pppd/ip-up Environment (MUST).
     Das Mapping (B165) ist nur Spiegel/Diagnose und darf kein Hard-Dependency für den Kill sein.
- Da DB-down Fail-Closed ist (B050), ist SQL Lookup im ip-up konzeptionell zulässig. Konsequenz: Wenn SQL down ist, muss Connect scheitern (PPP wird gekillt).

3) Lock-Contention Handling + fail-closed bis Apply (KANONISCH, MUST):
   Ziel:
   - Es darf keinen Zustand geben, in dem eine PPP-Session "hoch" ist, aber die Kernel-Policy nicht zuverlässig angewendet wurde.

   Bounded Retry/Backoff (MUST):
   - Wenn vpn-policy-apply mit TEMPFAIL_LOCKED endet, MUSS ip-up bounded retry/backoff ausführen.
   - Es MUSS ein max_total_time_window geben (bounded, kein endloses Warten).

   Zeitfenster (XP-Operability, MUST/SHOULD, SQL-first):
   - max_total_time_window SOLL (wenn SQL verfügbar) aus SQL-Settings gelesen werden.
   - Performance-Schutz (MUST): Wenn SQL-Settings nicht schnell (mit kleinem Timeout) abrufbar sind, MUSS ip-up sofort den Fallback nutzen
     (kein zusätzlicher SQL-Wait im Connect-Pfad; verhindert DoS/Latenz bei Login-Flooding).
   - max_total_time_window MUSS hart gecappt sein auf <= 15 Sekunden.
   - Notfall-Default (Fallback, klar markiert): default SHOULD = 10 Sekunden, falls SQL-Settings nicht verfügbar sind.

   fail-closed (MUST):
   - Wenn vpn-policy-apply innerhalb des max_total_time_window nicht SUCCESS liefert (weiterhin TEMPFAIL_LOCKED oder Error),
     MUSS ip-up die PPP-Session beenden (PPP-kill), damit kein unpoliced window entsteht.
   - PPP-kill erfolgt deterministisch über PPPD_PID aus dem pppd/ip-up Environment (MUST).
     Mapping (B165) ist nur Spiegel/Diagnose und darf kein Hard-Dependency für den Kill sein.
   - Wenn PPP-kill fehlschlägt: FATAL -> Alert/Logging (B330), weil das ein Sicherheitsbruch wäre (Session bleibt trotz fail-closed Forderung aktiv).

   PPPD_PID Quelle (MUST):
   - PPPD_PID MUSS aus pppd/ip-up Environment stammen.
   - FORBIDDEN: pgrep/ps zur PID-Ermittlung.

================================================================================
4) DISCONNECT TRIGGER (ip-down)
================================================================================
- Event: PPP-Session geht runter
- Verantwortlich: /etc/ppp/ip-down.d/99-vpn-hooks

SOLL ausführen (Reihenfolge):
1) Final Accounting Flush (B165):
   - final rx/tx lesen, delta bilden
   - Commit versuchen; bei DB down -> spool append

2) Cleanup / Stale vermeiden:
   - nft restricted cleanup für CLIENT_IP (falls Mapping noch vorhanden)
   - tc cleanup für PPP_IF (falls möglich)
   - nft: CLIENT_IP aus connect_pending_v4 löschen (idempotent, MUSS – sonst blockiert Reconnect).

3) Session-Mapping entfernen:
   - /run/vpn-sessions/<ppp_if>.env löschen

Hinweis:
- Selbst wenn Cleanup ausfällt, repariert Reconcile (B166) stale state spätestens <= 5 Minuten.

================================================================================
5) PANEL EVENT TRIGGER (sofortige Wirkung)
================================================================================
- Event: Panel verändert Kernel-Policy-relevanten Zustand (Claim/Unclaim/Quota/Expiry/Manual/Speed)
- Hinweis: Email-Verify (Verify-Wall) ist App-Layer und kein Kernel-Policy-Trigger; dafür kein nft/tc Apply nötig.
- Verantwortlich: Panel Backend (OpenResty/PHP)

MUSS ausführen (B166, STRICT):
- Single: vpn-policy-apply --connection-id=<id>
- Customer scope (optional, wenn eine Panel-Aktion customerweit wirken soll): vpn-policy-apply --customer-id=<id>

Hinweis:
- Panel ruft NICHT nft/tc direkt, sondern nur vpn-policy-apply.

================================================================================
6) SYSTEMD: POLICY RECONCILE TIMER (Option B)
================================================================================
- Zweck: Drift-Reparatur + stale cleanup + self-healing (B166)
- Intervall: alle 5 Minuten

Konzept-Units:
- vpn-policy-reconcile.service:
  - ExecStart: vpn-policy-apply --reconcile-all
  - Mode: BEST EFFORT
- Locking (MUST, Single-Writer, passend zu B166):
  - Reconcile/Apply dürfen niemals parallel laufen.
  - Mechanik: flock auf ein Lockfile unter /run ist akzeptiert (z.B. /run/vpn-policy-apply.lock).
  - Wenn Lock belegt: sauberer Abbruch (TEMPFAIL_LOCKED), keine Partial Applies.
  - Stale-Lock: definierte TTL/Break-Glass (Lock-Alter prüfen; Admin-Override möglich), damit Crash nicht dauerhaft blockiert.

- vpn-policy-reconcile.timer:
  - OnUnitActiveSec=5min

================================================================================
7) SYSTEMD: ACCOUNTING COLLECTOR TIMER
================================================================================
- Zweck: Batch Accounting via pppX counters + durable spool (B165)
- Intervall: 300s

Konzept-Units:
- vpn-accounting-collector.service:
  - ExecStart: vpn-accounting-collector
  - Liest /run/vpn-sessions + /sys/class/net/pppX/statistics
  - Batch-Commit in SQL; bei DB down -> spool

- vpn-accounting-collector.timer:
  - OnUnitActiveSec=300s

================================================================================
7.1) SYSTEMD: STALE SESSION JANITOR TIMER (B168)
================================================================================
- Zweck: Stale radacct Sessions schließen, damit Simultaneous-Use=1 nicht fälschlich blockiert (B168).
- Intervall: alle 5 Minuten

Konzept-Units:
- vpn-stale-session-janitor.service:
  - ExecStart: vpn-stale-session-janitor
  - Mode: BEST EFFORT (DB down -> späterer Lauf)
- vpn-stale-session-janitor.timer:
  - OnUnitActiveSec=5min

- Zusätzlich (On-Demand): FreeRADIUS kann vor Simultaneous-Use den Janitor gezielt aufrufen:
  - vpn-stale-session-janitor --subaccount-login=<User-Name> (B168)
  - Zweck: Reconnect ohne Lockout bei stale radacct.

- RADIUS Login-Flow (On-Demand Trigger vor Simultaneous-Use) ist in B169 definiert.

================================================================================
7.2) BOOT-ORDER / BOOT-RECONCILE (SERVER RESTART)
================================================================================
Problem:
- /run ist tmpfs und nach Boot leer (kein Mapping).
- nft/tc Policy-State muss nach Restart auf den echten Runtime-Zustand gebracht werden.

Boot-Strategie (KANONISCH):
1) Boot-Reconcile:
   - Einmalig nach Service-Start: vpn-policy-apply --reconcile-all (B166)
   - Ziel: nft/tc Sollzustand für aktuell aktive pppX Interfaces herstellen.

2) Boot-Janitor (verzögert):
   - Einmalig nach Boot-Reconcile (Delay empfohlen): globaler stale sweep (B168)
   - Ziel: stale radacct stop_time NULL bereinigen, damit Simultaneous-Use=1 nicht fälschlich blockiert.

Hinweis:
- Boot-Janitor darf mit Delay laufen (z.B. 60-120s), damit ip-up Mapping (/run/vpn-sessions) wieder aufgebaut wird.

================================================================================
7.3) SYSTEMD DEPENDENCIES (AFTER/REQUIRES) - START ORDER
================================================================================
Ziel:
- Policy/Collector/Janitor sollen erst laufen, wenn Netzwerk + VPN-Stack bereit ist.
- Boot-Reconcile darf nicht "zu früh" laufen (sonst keine pppX sichtbar).

Kanonische Abhängigkeiten (Konzept):
- Alle VPN-bezogenen Units (collector, janitor, reconcile/boot-reconcile) hängen an:
  - After=network-online.target
  - Wants=network-online.target

- RADIUS:
  - freeradius.service After=network-online.target
  - (strongSwan/xl2tpd können parallel starten; RADIUS kann früh, ist ok)

- Boot-Reconcile Unit (einmalig):
  - After=network-online.target strongswan.service xl2tpd.service freeradius.service
  - Wants=strongswan.service xl2tpd.service freeradius.service
  - ExecStart: vpn-policy-apply --reconcile-all
  - Restart=no (oneshot)
  - Optional: ExecStartPre=/bin/sleep 10 (kleiner Delay, um pppX zu sehen)

- Boot-Janitor Unit (einmalig, verzögert):
  - After=boot-reconcile.service
  - ExecStart: vpn-stale-session-janitor (global)
  - ExecStartPre=/bin/sleep 60..120 (Delay, damit /run/vpn-sessions via ip-up wieder da ist)

Hinweis:
- ip-up bleibt der primäre "strict" Trigger pro Session.
- Boot-Reconcile ist Backstop, nicht Primärmechanismus.

================================================================================
7.4) DB DOWN BEHAVIOR (FAIL-CLOSED WITHOUT BOOT DEADLOCK)
================================================================================
Ziel:
- SQL ist Wahrheit (B050), Fail-Closed für Auth/State.
- Trotzdem sollen Services sauber starten (kein Boot-Deadlock), auch wenn DB temporär down ist.

Kanonisch:
- Services dürfen starten, auch wenn DB down ist:
  - strongSwan, xl2tpd, OpenResty/PHP, FreeRADIUS, policy-apply tooling, collector/janitor timers.
- AUTH bleibt STRICT Fail-Closed (B050):
  - Wenn SQL nicht erreichbar -> Login muss scheitern (kein Accept).
- On-Demand Cleanup/Janitor/Collector sind BEST EFFORT:
  - DB down -> skip/fail (kurzer Timeout), loggen (sparsam), nächster Lauf holt nach.
- Boot-Reconcile:
  - Ist primär Kernel-basiert (pppX + nft/tc Soll/Ist).
  - Wenn SQL für Statusabfragen benötigt wird und DB down ist -> reconcile läuft "no-op" bzw. bricht best effort ab.
  - Keine "Ratespielchen" ohne SQL.

================================================================================
8) LOCKING (EMPFOHLEN)
================================================================================
- Reconcile sollte nicht parallel laufen:
  - /run/vpn-policy-reconcile.lock (flock)
- Accounting Collector sollte ebenfalls nicht parallel laufen:
  - /run/vpn-accounting-collector.lock (flock)

================================================================================
8.1) ADMIN HARDCUT TOOL (D012)
================================================================================
Zweck:
- Admin kann eine aktive VPN-Session sicher beenden (Hardcut-first).
- Panel (www-data) darf NIEMALS direkt killen -> Privilege Separation ist Pflicht (siehe B285).

Tool:
- /usr/local/bin/vpn-session-kill <vpn_connection_id>

MUST Verhalten (High-Security, deterministisch):
- Input Validation im Tool:
  - vpn_connection_id MUSS strikt Integer sein (sonst exit != 0, audit-log).
- Kill-first:
  - Session technisch beenden (pppd/xl2tpd), bevorzugt über PID/Interface aus Runtime-Mapping (B165/B168).
  - Kein "Clear lock only", kein DB-only Cleanup.
- Danach:
  - vpn-policy-apply / reconcile ausführen, um nft/tc deterministisch zu korrigieren.
  - Locks (active_session_locks) best-effort entfernen (falls vorhanden).
- Erwartung:
  - Accounting-Stop wird idealerweise durch den Kill ausgelöst (RADIUS schließt radacct normal).
  - Falls Accounting-Stop ausbleibt: Janitor (B168) schließt stale radacct später (Truth bleibt radacct).

Security:
- Das Panel darf das Tool nur via sudo ausführen (www-data -> nur dieses Tool, nur mit validierten Args; siehe B285).

================================================================================
9) TESTS (WIRING)
================================================================================
- ip-up Test: Mapping file wird erstellt + vpn-policy-apply wird aufgerufen.
  - Mapping-Minimum ist erfüllt: CONNECTION_ID, PPP_IF, CLIENT_IP, START_TS, PPPD_PID vorhanden; SESSION_ID optional.
- ip-down Test: Final flush + cleanup + mapping removal.
- Panel Event Test: Policy Änderung -> sofort vpn-policy-apply Aufruf.
- Timer Test: Reconcile läuft alle 5 Minuten; Accounting Collector alle 300s.
- PPP Username Source Test: ip-up nutzt PEERNAME; wenn leer, nutzt USER/PPPLOGNAME; wenn weiterhin leer -> kein Mapping, kein apply, Diagnose-Log.
- Boot-Reconcile Test: Server Neustart -> reconcile-all läuft einmalig -> nft/tc passen zu aktiven pppX Interfaces.
- Boot-Janitor Test: Nach Boot (mit Delay) läuft global sweep -> stale radacct wird geschlossen ohne aktive Sessions zu treffen.
- Start-Order Test: Nach Boot sind network-online, strongSwan, xl2tpd, freeradius aktiv bevor boot-reconcile läuft.
- Early-Reconcile Protection Test: boot-reconcile läuft nicht bevor network-online erreicht ist; optional Delay verhindert "0 pppX" Fehlzustand.
- DB Down Boot Test: DB down beim Boot -> Services starten trotzdem; Auth fail-closed; collector/janitor skippen best effort ohne Loop/Spam.
- Lock-Contention Test (TEMPFAIL_LOCKED): vpn-policy-apply Lock künstlich belegt -> ip-up macht bounded retry/backoff -> wenn kein SUCCESS innerhalb Window: PPP-kill (fail-closed) erfolgt deterministisch.
- Apply-Failure Test: vpn-policy-apply liefert Error/Timeout -> ip-up beendet Session (fail-closed) -> kein Traffic-Fluss ohne Policy.
- PPPD_PID Source Test: PPPD_PID wird aus pppd/ip-up Environment übernommen; pgrep/ps wird nicht benutzt (Audit-Check).

================================================================================
CHANGELOG
================================================================================
- v1.15 (2026-01-14): Konsistenz/Terminologie: Runtime-Aktivitätsdefinition präzisiert ("vpn_connection_id aktiv?" statt "connection_id aktiv?"); ip-up Apply-Aufruf um Klarstellung ergänzt (CONNECTION_ID = vpn_connection_id; Referenz B166). Keine Verhaltensänderung.
- v1.14 (2026-01-14): Admin Hardcut Tooling gemäß D012 ergänzt: /usr/local/bin/vpn-session-kill + Wiring/Verhaltensregeln (Kill-first -> Reconcile; sudo/Privilege Separation Referenz B285).
- v1.13 (2026-01-10): Präzisierung: PPP-kill darf nicht vom Runtime-Mapping abhängen; PPPD_PID Quelle ist pppd/ip-up Environment, Mapping nur Spiegel/Diagnose. ip-up Zeitfenster: SQL-Settings nur bei „schnell verfügbar“, sonst sofort Fallback (keine Connect-Latenz/DoS). Konsistenzfix: fail-closed Kill-Quelle präzisiert (PPPD_PID aus pppd/ip-up env, nicht aus Mapping).
- v1.12 (2026-01-10): Runtime-Aktivitätsdefinition auf VALID Mapping umgestellt (konsistent zu B165/B168; Ghost-Files sind kein Aktivitätsbeweis). ip-up Fail-Closed gehärtet: Wenn PPP Username nicht ermittelbar ist oder SQL Lookup fehlschlägt/DB down ist, MUSS die PPP-Session deterministisch via PPPD_PID (env) gekillt werden (kein unpoliced window).
- v1.11 (2026-01-09): ip-up Mapping-Minimum kanonisiert: PPPD_PID + START_TS (MUST), SESSION_ID nur optional/diagnostisch (kein Kill-Handle). Lock-Contention Zeitfenster SQL-first präzisiert (SQL Setting bevorzugt, Hard Cap <=15s, Fallback default SHOULD 10s). Tests um Mapping-Minimum ergänzt.
- v1.10 (2026-01-09): ip-up kanonisiert: bounded retry/backoff bei TEMPFAIL_LOCKED + fail-closed bis Apply (bei ausbleibendem SUCCESS -> PPP-kill via PPPD_PID). Mapping-Inhalt um PPPD_PID ergänzt. Zeitfenster normiert (MUST <= 15s, default SHOULD 10s). PPPD_PID Quelle aus pppd/ip-up env; pgrep verboten.
- v1.9 (2026-01-09): ip-up SQL Lookup korrigiert: status='ACTIVE' entfernt; Statusfilter an State-Machine (PREPROVISIONED/CLAIMED) angepasst.
- v1.8 (2026-01-07): Locking im Reconcile Wiring von OPTIONAL auf MUST hochgestuft + Single-Writer Regeln konkretisiert (TEMPFAIL_LOCKED + Stale-Lock).
- v1.7: Panel-Event-Trigger korrigiert: Verify entfernt (App-Layer), Kernel-Trigger sind Claim/Unclaim/Quota/Expiry/Manual/Speed; Gate2-Begriff entfernt. Runtime-Aktivitätsdefinition pro connection_id (scan /run/vpn-sessions/*.env) explizit als kanonisch referenziert (B165).
- v1.6: DB-down Verhalten definiert (Fail-Closed für Auth, Services starten ohne Deadlock, Best-Effort für collector/janitor/reconcile), inkl. Test.
- v1.5: Systemd Start-Order/Dependencies für Boot-Reconcile + Boot-Janitor ergänzt (After/Wants network-online + VPN-Stack), inkl. Tests.
- v1.4: Boot-Reconcile/Boot-Janitor Strategie ergänzt (reconcile-all beim Boot, Janitor global verzögert), inkl. Tests.
- v1.3: systemd wiring für B168 ergänzt (vpn-stale-session-janitor.service/.timer, 5min).
- v1.2: PPP Username Quelle festgelegt (PEERNAME, Fallback USER/PPPLOGNAME) für Option 1 SQL Lookup im ip-up.
- v1.1: ip-up ermittelt CONNECTION_ID via SQL Lookup über PPP Username == vpn_connections.subaccount_login (UNIQUE).
- v1.0: initial wiring für Hooks + systemd Timer (Policy Reconcile 5min, Accounting Collector 300s)
================================================================================